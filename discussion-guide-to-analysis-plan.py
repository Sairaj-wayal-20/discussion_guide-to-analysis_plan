# -*- coding: utf-8 -*-
"""Copy of final_word.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G_GBdKo1YguAVcPLBEyGrMYf_tFzUyU4
"""

import warnings
warnings.filterwarnings("ignore")

from openai import OpenAI
client = OpenAI(api_key='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')

from docx import Document
import pandas as pd
import re
import sys

extracted_original_questions = []

def extract_questions(doc_path):
    doc = Document(doc_path)
    questions = []
    list_start = False

    for i, paragraph in enumerate(doc.paragraphs):
        text = paragraph.text
        # print(paragraph.style.name)

        if text.endswith("?"):
            extracted_original_questions.append(text)

            if "PROBE" in text:
                questions.pop()
                current_questions = (
                    doc.paragraphs[i - 1].text.strip()
                    + " "
                    + re.sub(r"^PROBE", " ", text)
                )
                questions.append(current_questions)
            elif "…" in text:
                questions.pop()
                current_questions = (
                    doc.paragraphs[i - 1].text.strip() + " " + re.sub(r"^…", " ", text)
                )
                questions.append(current_questions)
            elif "[" in text:
                questions.pop()
                current_questions = (
                    doc.paragraphs[i - 1].text.strip()
                    + " "
                    + re.sub(r"\[([^]]+)\]", " ", text)
                )
                questions.append(current_questions)
            elif "Why this image?" in text:
                questions.pop()
                current_questions = (
                    doc.paragraphs[i - 1].text.strip()
                    + " Why this image?"
                    + re.sub(r"^Why this image?", "", text)
                )
                questions.append(current_questions)
            elif "Why?" in text:
                questions.pop()
                current_questions = (
                    doc.paragraphs[i - 1].text.strip()
                    + " Why?"
                    + re.sub(r"^Why?", "", text)
                )
                questions.append(current_questions)
            elif "Ease of use?" in text:
                questions.pop()
                current_questions = (
                    doc.paragraphs[i - 1].text.strip()
                    + " Ease of use?"
                    + re.sub(r"^Ease of use?", "", text)
                )
                questions.append(current_questions)
            elif "E.g" in text:
                questions.pop()
                current_questions = (
                    doc.paragraphs[i - 1].text.strip()
                    + " E.g.,"
                    + re.sub(r"^E.g", "", text)
                )
                questions.append(current_questions)
            elif "Why is that?" in text:
                questions.pop()
                current_questions = (
                    doc.paragraphs[i - 1].text.strip()
                    + " Why is that?"
                    + re.sub(r"^Why is that?", "", text)
                )
                questions.append(current_questions)
            elif "Why not the others?" in text:
                questions.pop()
                current_questions = (
                    doc.paragraphs[i - 1].text.strip()
                    + " Why not the others?"
                    + re.sub(r"^Why not the others?", "", text)
                )
                questions.append(current_questions)
            elif ">>" in text:
                questions.pop()
                current_questions = (
                    doc.paragraphs[i - 1].text.strip() + " " + re.sub(r"^>>", "", text)
                )
                questions.append(current_questions)

            else:
                questions.append(text)


    return questions

filename=sys.argv[1]

#extracted_original_questions

#questions = extract_questions("23079 MDD Market Structure - Discussion Guide - v3.0 clean.docx")
uploaded_filename =f"static/files/{filename}"
doc = Document(uploaded_filename)
questions = extract_questions(uploaded_filename)

df = pd.DataFrame({'Questions': questions})

from docx.enum.text import WD_COLOR_INDEX

def highlight_text(doc, questions):
    for paragraph in doc.paragraphs:
        if all(question not in paragraph.text for question in extracted_original_questions):
            for run in paragraph.runs:
                run.font.highlight_color= WD_COLOR_INDEX.YELLOW   # Set RGB color for highlighting

# Define your questions
#questions = questions

doc_path = f'static/files/{filename}'
doc = Document(doc_path)

highlight_text(doc, questions)

doc.save('static/files/unselected-highlighted.docx')

question=" "
for i, row in df.iterrows():
  question += str(i + 1) + ")" + row["Questions"] +"\n"

def questions(data):
  completion = client.chat.completions.create(
          model="gpt-3.5-turbo-1106",
          messages=[
              {
                  "role": "system",
                  "content": """Combine sub-questions with their corresponding main questions in the dataset. Keep the original main questions intact without skipping any.
                                Avoid adding sub-question numbers and store the combined content into the previous main questions. Optimize the output while maintaining the meaning of the questions. Each question must be separated using a "\n".

                                Questions -



                """,
              },
              {"role": "user", "content": data},
          ],
      )
  return completion.choices[0].message.content
#print(question)

output = questions(question)
print(output)



result=output.split("\n")
#print(result)

df1 = pd.DataFrame(columns=["Questions","tags"])


for q in result:
    if q == "" :
      continue
    #print(question_text)
    df1 = df1.append({"Questions": q} , ignore_index=True)

question_tag=" "
for i, row in df1.iterrows():
  question_tag += str(i + 1) + ")" + row["Questions"] +"\n"

#print(df1)

def tags(data):
    responses = []
    #for question in data:
        #print(data)
    completion = client.chat.completions.create(
    model="gpt-3.5-turbo-1106",
    messages=[
                {
                    "role": "system",
                    "content": """I want to create a shorter, concise version and topic of just giving the answer  strictly in  3-5 words and also giving each question for each tag.

                                Here are some examples -

                                Actual Question - Without giving away anything personally identifiable, can you please briefly introduce yourself and tell me a little bit about your practice setting?
                                Short Version - introduce yourself and  practice setting

                                Actual Question - Approximately how many patients do you see in a typical month for major depressive disorder (MDD)?
                                Short Version - patients you see in a month for MDD

                                Actual Question - How do you define MDD? How do they think about symptoms? Part of MDD or separate, even if potentially related (anxiety, anhedonia, insomnia)?
                                Short Version - define MDD, about symptoms, Part of MDD or separate anxiety, anhedonia, insomnia

                                Now do it for below question. Answer output only, no heading,no Question number, context or pretext.
                """,
                },
                {"role": "user", "content": data},
            ],
        )
    responses.append(completion.choices[0].message.content)
    return responses

tag_output = tags(question_tag)



tag_output = re.split('\n', ','.join(tag_output))

tag_output
#print(tag_output)

df1["tags"]=tag_output


df1.to_excel(f"static/files/Analysis-Plan-{filename}.xlsx", index=False)

import zipfile
import os

# File paths
output_file1 = f"static/files/Analysis-Plan-{filename}.xlsx"
output_file2 = 'static/files/unselected-highlighted.docx'
zip_file_name = f"static/files/output-{filename}.zip"

# Create a Zip file
with zipfile.ZipFile(zip_file_name, 'w') as zip_file:
    # Add files to the Zip file
    zip_file.write(output_file1, f'output-{filename}.xlsx')
    zip_file.write(output_file2, 'unselected-highlighted.docx')